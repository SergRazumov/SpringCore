package ru.alishev.model;import org.springframework.beans.BeansException;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.config.BeanPostProcessor;import org.springframework.context.ApplicationContext;import org.springframework.context.annotation.Lazy;import org.springframework.stereotype.Component;import org.springframework.util.ReflectionUtils;import javax.management.ReflectionException;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.util.Arrays;import java.util.HashMap;import java.util.Map;import java.util.Random;/** * Класс для обработки всех Bean классы которых имеют эту аннотацию тут речь о InjectRandomInt */@Componentpublic class InjectRandomIntBeanPostProcessor implements BeanPostProcessor {    private final Map<String, Class> map = new HashMap<>();    @Autowired    private ApplicationContext context;    @Override    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException {        Field[] fields = bean.getClass().getDeclaredFields();        Arrays.stream(fields).forEach(field -> {            InjectRandomInt annotation = field.getAnnotation(InjectRandomInt.class);            if (annotation != null) {                int min = annotation.min();                int max = annotation.max();                max -= min;                int num = (int) (Math.random() * ++max) + min;                field.setAccessible(true); // устанавливаем в private поле значение т.к private делаем доступ                ReflectionUtils.setField(field, bean, num);                System.out.println("Phase 1 volume after postProcessBeforeInitialization this class field = " + num);            }            try {                if (field.getName().equals("switchMusicPlayer")) {                    field.setAccessible(true);                    System.out.println("Phase 1 postProcessBeforeInitialization already autowired ? " + field.get(bean));                }                if (field.getName().equals("name")) {                    field.setAccessible(true);                    System.out.println("Phase 1 postProcessBeforeInitialization already property variable ? " + field.get(bean));                    //TODO: поправить и сделать else                }            } catch (IllegalAccessException e) {                throw new RuntimeException(e);            }        });        Class<?> beanClass = bean.getClass();        if (beanClass.isAnnotationPresent(Profiling.class)) {            map.put(beanName, beanClass);            System.out.println("Phase 1 after postProcessBeforeInitialization annotation up class ");        }        for (Method method : beanClass.getDeclaredMethods()) {            if (method.isAnnotationPresent(PostProxy.class)) {                System.out.println("Phase 1 PostProxy annotation up method");            }        }        return bean;       // return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);    }    @Override    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException {        Field[] fields = bean.getClass().getDeclaredFields();        Arrays.stream(fields).forEach(field -> {            InjectRandomInt annotation = field.getAnnotation(InjectRandomInt.class);            if (annotation != null) {                int min = annotation.min();                int max = annotation.max();                max -= min;                int num = (int) (Math.random() * ++max) + min;                field.setAccessible(true); // устанавливаем в private поле значение т.к private делаем доступ                ReflectionUtils.setField(field, bean, num);                System.out.println("Phase 3 volume after postProcessAfterInitialization this class field = " + num);            }        });        Class<?> newbeanClass = bean.getClass();        if (newbeanClass.isAnnotationPresent(Profiling.class)) {            System.out.println("Phase 3 after postProcessAfterInitialization annotation up class ");            System.out.println("-----------------Закончилась фаза postProcessBeforeInitialization и postProcessAfterInitialization для внешних аннотаций класса---------------------\n");            //        }        for (Method method : newbeanClass.getDeclaredMethods()) {            if (method.isAnnotationPresent(PostProxy.class)) {                System.out.println("Phase 3 PostProxy annotation up method");            }        }        Class<?> beanClass = map.get(beanName);        if (beanClass != null) {            System.out.println("Phase 3 after postProcessAfterInitialization");            //            //Метод генерит объект из нового класса который сгенерит сам же на лету, принимает класс loader при помощи которого            //класс загрузится в heap, второй параметр список интерфейсов которые имплементит сгенеренный класс,            return new ClassicalMusic();        }        return bean;      //  return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);    }}